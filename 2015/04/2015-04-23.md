## Idea

* A mobile Web App managing files on the computer
  * Server run by the computer, phone connects to 192.168.xx.xxx:yyyy and use the dashboard to CRUD files
  * Node.js as backend
  * Try some cool toys on the frontend, maybe react?
  * Actually...deleted files should be moved to trash...how?

## V8
* [Chrome V8](https://developers.google.com/v8)
* [Building V8 with GYP](https://code.google.com/p/v8-wiki/wiki/BuildingWithGYP)
* [Google I/O 2012 - Breaking the JavaScript Speed Limit with V8 ](https://www.youtube.com/watch?v=UJPdhx5zTaw)

### Notes on Google I/O 2012 V8 talk
[Google I/O 2012 - Breaking the JavaScript Speed Limit with V8 ](https://www.youtube.com/watch?v=UJPdhx5zTaw)

#### Hidden Class
* Weak types makes JS optimization difficult, so V8 use the hidden class trick
* Hidden class <-> Backing store
* Each time you assign a member, a new hidden class is created
* If you create a member later at run time, the generated & optimized hidden class created before *cannot be reused*
* **TL;DR**: Initialize all your memebrs in the constructor

#### Tagging numbers
* 31-bit for value/pointer, 1 bit as flag
* Integer -- flag is 0, signed integer stored in that 31-bit
* If the number is larger than 31-bit(signed), flag turns to 1, the value turns to a pointer to a double(boxing)
* **TL;DR**: keep the numbers smaller than 31-bit(signed)

#### Arrays
* Two storage mode
  * Compact key sets -> linear buffer
  * Sparse arrays -> Hash table!
* **TL;DR**
  * Don't make V8 switch to dictionary mode!
  1. Avoid empty holes(undefined, etc.)
  2. Start at 0
  3. Don't pre-allocate a large array that you won't fill in very soon -> big dictionary!
  4. Don't load/delete elements not yet initialized, especially the one-pass-end element(e.g. accessing a[0] in an empty array)
    * access usually = rvalue

#### Double array
* V8 will unbox a double array if it is certain that the array only has doubles
  * The hidden class of elements will change
  * Integer elements -> 31-bit value + 1-bit flag
  * Double elements -> 31-bit pointer to double + 1-bit flag
  * Double arrays/Integer mixed with doubles -> elements truns into IEEE representations of doubles
* Unbox: take out the IEEE representation of the doubles, store them in a linear buffer
  * This "realize -> unbox" process comes with a cost
  * If you add something that's not double later, the array will be boxed back -> cost!
  * **TL;DR**
    * Use literals can avoid this cost for transition
    * Don't mix numbers with non-numerical values in the array

#### Full compiler, not that fast
* Assumes little about types
* Inline Caches to refine knowledge at run time
  * Validate type(by checking hidden classes) first, then do the work
  * **TL;DR**
    * Try to keep the hidden class of your objects the same at runtime
      * If the class changes, there will be overhead(no more inlining)
    * Monomorphic types are much more easier to optimize

#### Optimizing compiler
* Recompile hot functions
* Use types tkaen from IC and **inline** function calls and operations(No calls and unecessary preparations!)
* Some features(e.g. try-catch in 2012) can not be optimized
* **TL;DR**:
  * `d8 --trace-opt xx.js` to see what is optimized
  * `d8 --trace-bailout xx.js` to see what is not optimized
  * Wrap code that can be optimized into functions first, **then** mix it with the code that cannot be optimized
    * If you just mix them normally, no one can be optimized
* Optimization is speculative
  * Invalid assumptions lead to deoptimization
    * Throws away optimized code and use the code generated by the full compiler
    * Recompilation is possible, but it will be slow for a short time before recompilation
    * `d8 --trace-deopt xx.js`
* Pass `--js-flags="--trace-* ..."` to Chrome
* Use `--prof`


## WebKit
* [WebKit for Developers](http://www.paulirish.com/2013/webkit-for-developers/)