## ES6

### [ES6 In Depth: Generators, continued](https://hacks.mozilla.org/2015/07/es6-in-depth-generators-continued/)

* The action is synchronous and single-threaded

#### `generator.return()`

```javascript
function* gen() {
  try {
    yield 'A';
    yield 'B';
    yield 'C';
    // ... yield some more values ...
  } finally {
    console.log('cleaning up');
  }
}

var generator = gen();
for (var value of generator) {
  console.log(value);
  if (value === 'B')
    generator.return();  // shows 'cleaning up', and no 'C' later
}
```
* If you call `generator.return()`, the `finally` block in the generator will be executed
  * Good for exceptions/early breaks
  * Note: it's like change the `yield` in your generator into `return`, which will also cause the `finally` block to be executed
* Not supported in Chrome yet: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)
* It's possible for a generator to be garbage collected before executing its `finally` block(e.g. you directly `break` out of the `for-of` without calling `generator.return()`)
* Usually you use it like this:

  ```javascript
  for (var value of generator) {
    try {
      // do something with value
    } catch {
      generator.return();
      // do its own error handling
    }
  }
  ```

#### Generator for async operation

* The key is: inside a generator function, `yield` can return a value. It returns what's passed by the caller in `generator.next(something)`, which means you have a way to let the generator know what to do next by using the information passed by its caller.
* So your generator function can not only pass things to its caller, but also receive things from its caller -- and most importantly, what it receives can be changed over each stage! (It's not like your normal parameter passing because in that case you can only pass data once at the beginning)
* Typically, you `yield` promises
* In this way, you can keep calling generators, **pass its return value to itself** until it finishes:

  ```javascript
  function runGeneratorOnce(g, result) {
    var status = g.next(result);
    if (status.done) {
      return;  // phew!
    }

    // The generator has asked us to fetch something and
    // call it back when we're done.
    doAsynchronousWork(
      status.value,
      function (err, nextResult)  {
        if (err) g.throw(err);
        runGeneratorOnce(g, nextResult);
      };
  }

  function * generator() {
    try {
      var b = yield 'A';
      var c = yield b;
      var d = yield c;
      } catch {
        // can catch errors from the caller
      }

  }
  ```

#### `generator.throw()`

* Using this, you can let the caller notify the generator it bumps into somehing wrong, and the generator might need to know it.
* You can catch the error generated by the caller in your generator, but if you don't catch it inside the generator whose `.throw()` is called, the error will be thrown right back at the caller

#### `yield *`

* `yield`s everything inside the generator.

  ```
  yield *iter;
  // is like
  for (var value of iter) {
    yield value
  }
  ```
* You can use it to maintain the order of your operations. If you `yield *` something, you can be sure that it will have nothing more to `yield` before the `yield *` statment ends.

## This looks interesting

jQuery-like, but much simpler.

* [DOMtastic](https://github.com/webpro/DOMtastic)
* [DOMtasticâ€™s $.baseClass](https://medium.com/@webprolific/domtastic-s-baseclass-437f142e8bf4)

